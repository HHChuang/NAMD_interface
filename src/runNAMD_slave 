#!/bin/bash
################################################################
# 
#   Purpose: 
#       Use Multiconfigurational Ehrenfest dynamics and QChem 
#   (SF-TDDFT) for nonadiabatic molecular dynamic simulation on 
#   HPC platform (ARC4). 
# 
#   Input:   
#       $1 = first point of trajectory 
#           1. *.iniPM (coordinate and momentum in a.u.)
#           2. *_nonad.out (QChem output file)
# 
#       $2 = time step in a.u. (10. or 2.5)
# 
#   Pre-requested:
#       1. EST: QChem program 
#       2. Nuclear parts: prop_prelim.x and prop_corr.x 
# 
#     2022/11/30, Grace, H.G.Chuang@leeds.ac.uk
# 
################################################################

function main(){
    # 1. Check environmental variables
    source ~/.bashrc
    qchemProg="qchem"
    propPrelim="/home/home02/chmhch/NAMD_src/prop_prelim.x"
    propCorr="/home/home02/chmhch/NAMD_src/prop_corr.x"

    # 2. Set parameters (global variables in bash shell script)
    setParameters $@

    # 3. Propagate trajectory 
    if [ $fileExten == 'iniPM' ] # 3.1 Start from molecular position and momentum 
    then 
        # Calculate the first electronic wavefunction (WF) and propagate the first nuclear geometry.
        # input: 
        #       $*,iniPM 
        # output: 
        #       $*.0, $*.p, $*.1, ${*}.out, $*_WF 
        gen1stDynamicFile $rootName 

        # Based on the previous WF, propagate molecule by reading WF with new generated structure one-by-one. 
        propTraj $rootName 
    elif [ $fileExten == 'out' ] # 3.2 Start from existed WF and molecular geometry. 
    then 
        propTraj $rootName 
    else 
        echo 'Wrong file extension, stop program.'
        exit 
    fi 
}

function setParameters(){
    # Check if the input argument exist or not.
    [ "$1" == "" ] && echo "File $1 is not exist, stop program." && exit


    # Nuclear dynamic setting 
    natom=9
    nstat=7
    nbranch=0
    time_ini=0.
    timestep=$2  # a.u., 2.4189 * 10^-17 
    if [ $timestep == '10.' ]
    then 
        tot_nsteps=900
    elif [ $timestep == '2.5' ]
    then 
        tot_nsteps=3000
    fi 

    # Check the file extension 
    fileExten=$(echo $1 | cut -d '.' -f 2 )

    # Depend on the file extension, decide the $rootName. 
    if [ $fileExten == 'iniPM' ]
    then 
        rootName=$(echo $1 | cut -d '.' -f 1)
        step_ini=1
    elif [ $fileExten == 'out' ]
    then 
        rootName=$(echo $1 | sed 's/_/ /g' | awk '{print $1"_"$2}' )
        step_ini=$(echo $1 | cut -d _ -f 3)
    fi 

    # Electroic setting 
    charge=0
    multi=3
    statlist=()
    for ((i=1; i <= $nstat; i++))
    do 
        statlist+=($i)
    done
}

function gen1stDynamicFile(){
    # $1 = root of filename 
    rootName=$1 

    # Step 1. First step of nuclear dynamics simulation; calculate EST information for nuclear propagation.
    #   Input: 
    #       Molecular coordinate and momentum 
    #   Output: 
    #       $1.0 
    # echo $rootName.0 

    echo "$natom $nstat   ! Number of atoms and number of states" > $rootName.0 
    echo "$nbranch ! Branch number; 0 - no cloning " >> $rootName.0 
    echo "$time_ini $timestep !Time and timestep " >> $rootName.0 
    echo '! Positions' >> $rootName.0 
    cat $rootName.iniPM >> $rootName.0
    echo '!Ehrenfest amplitudes (complex numbers)'  >> $rootName.0
    echo '0.0000000000000000E+00' >> $rootName.0
    echo '0.0000000000000000E+00' >> $rootName.0
    echo '0.0000000000000000E+00' >> $rootName.0
    echo '0.1000000000000000E+01' >> $rootName.0
    echo '0.0000000000000000E+00' >> $rootName.0
    echo '0.0000000000000000E+00' >> $rootName.0
    echo '0.0000000000000000E+00' >> $rootName.0
    echo '!Potential energies, #state' >> $rootName.0

    # Step 1.1 Calculate nonadiabatic coupling, and calculate and store the WF for the following process. 
    calcQChemNonad $rootName SAD $rootName.0  

    # Step 1.2. Force calculation in different excited state 
    for (( i=1;i<= $nstat;i++ ))
    do 
        calcQChemForce $rootName $i $1.0
    done 

    # Step 1.3 Add EST data to the dynamic calculation input file 
    grep 'Total energy for state ' $rootName\_nonad.out \
        | awk '{print $6, $5}' | sed 's/://g' | head -n $nstat >> $rootName.0
    
    get_force $rootName.0 $rootName\_force 
    get_nonad $rootName.0 $rootName\_nonad.out 

    # Step 2. Second and third step of nuclear dynamics simulation; call $propPrelim and $propCorr for nuclear propagation. 
    #   Input: 
    #       $1.0
    #   Output: 
    #       $1.p, $1.1
    prop1PT $1 
}

function propTraj(){
    #   Input:
    #     $1 = rootName of all files
    # 
    #   Output: 
    #     1. $rootName.1
    #     2. $rootName\_nonad.out 
    #     3. $rootName\_force_#.out 
    #     4. /$rootName\_WF
    # 

    # Set parameters
    rootName=$1
    nameWFDir=($rootName\_WF) # Store the directory name of electronic wavefunctions (WF)
    nwfDir=3 # maximum number of stored WF 
    if [ $step_ini == 1 ] 
    then 
        pt_name_i=$rootName
    else 
        pt_name_i=$rootName\_$(($step_ini - 1 )) 
    fi 

    # Calculate the first $nwfDir points in order to store electronic wavefunctions
    for (( step_i=$step_ini;step_i<=$(($step_ini + $nwfDir));step_i++ ))
    do 
        pt_name=$rootName\_$step_i
        cp $pt_name_i.1 $pt_name.0
        cp -r $pt_name_i\_WF $pt_name\_WF
        prop1PT $pt_name Read
        pt_name_i=$pt_name 
        nameWFDir+=($pt_name\_WF)
    done 

    # Keep replacing the stored WFs, and then propagate molecule.
    for (( step_i=$(($step_ini + $nwfDir + 1));step_i<=$tot_nsteps;step_i++ ))
    do 
        pt_name=$rootName\_$step_i
        cp $pt_name_i.1 $pt_name.0
        cp -r $pt_name_i\_WF $pt_name\_WF
        prop1PT $pt_name Read
        pt_name_i=$pt_name 
        nameWFDir+=($rootName\_$(($step_i-$nwfDir))\_WF)
        echo ${nameWFDir[@]} | xargs rm -rf 
    done 
    rm -f qchemOption.tmp tmp.tmp 
}

function calcQChemNonad(){
    # $1 = root of QChem file name 
    # $2 = syntax for electronic wavefunction 
    # $3 = dynamic file; *.0, *.p or *.1

    name_n=$1\_nonad
    qchemOptionNonad $2 # output: qchemOption.tmp
    genqchemInp  $name_n $3 qchemOption.tmp
    $qchemProg $name_n.inp $1\_WF > $name_n.out
    check_calc $1\_WF $name_n
}

function calcQChemForce(){
    # $1 = root of QChem file name 
    # $2 = order of excited state 
    # $3 = dynamic file; *.0, *.p or *.1

    name_f=$1\_force\_$2
    qchemOptionForce $2 # output: qchemOption.tmp
    genqchemInp  $name_f $3 qchemOption.tmp
    $qchemProg $name_f.inp $1\_WF > $name_f.out
    check_calc $1\_WF $name_f
}

function prop1PT(){
    # '''
    #     $1 = root of filename 
    #     output:
    #         $1.1
    # '''
     
    # Step 1. Dynamic preliminary calculation
    $propPrelim $1 # input: $1.0, output: $1.p

    # Step 2. Electronic structure calculation
    # Step 2.1. Nonadiabatic calculation
    #   calculate electronic energy and store WF 
    calcQChemNonad $1 Read $1.p

    # Step 2.2. Force calculation in different excited state
    for (( i=1;i<= $nstat;i++ ))
    do 
        calcQChemForce $1 $i $1.p
    done 

    # Step 2.3 Add EST data to the dynamic calculation input file 
    # echo '!Potential energies, #state' >> $1.p
    grep 'Total energy for state ' $1\_nonad.out \
        | awk '{print $6, $5}' | sed 's/://g' | head -n $nstat >> $1.p
    
    get_force $1.p $1\_force 
    get_nonad $1.p $1\_nonad.out 

    
    # Step 3. Correction of dynamic information
    # Correct final momenta and Ehrenfest amplitudes using electronic structure data from both initial and final point
    $propCorr $1 # output: $1.1
}

function get_nonad(){
    # $1 = name of input for dynamic calculation
    # $2 = name of QChem output file 

    name=$1
    name_nonad=$2 

    echo '!Coupling vector, #state1 < #state2,  #component !!The code reads only 3*n_atoms*n_states*(n_states-1) lines for coupling!!!' >> $name
    
    k=0
    for ((i=1; i<=$nstat; i++))
    do 
        for ((j=$i+1; j<=$nstat; j++))
        do
            echo $i,$j,$((4 + $k*($natom+4) )), $((3+$natom + $k*($natom+4) ))
            grep -A $(($natom + 2 )) 'derivative coupling without ' $name_nonad \
            | sed -n "$((4 + $k*($natom+4) )), $((3+$natom + $k*($natom+4) )) p" | awk '{print $2,$3,$4}' > coupling.tmp 
            cat coupling.tmp 
            component=1
            for ((na=1; na<=$natom; na++))
            do 
                for ((coord=1; coord<=3; coord++))
                do 
                    cp=$(sed -n "$na, $na p " coupling.tmp | awk "{print \$$coord}" ) 
                    echo $cp $i $j $component >> $name
                    component=$(($component + 1))
                done 
            done 
            k=$(($k + 1)) # derivative coupling matrix 
        done 
    done 
    rm -f coupling.tmp 
}

function get_force(){
    # '''
    #     $1 = name of input for dynamic calculation
    #     $2 = root name of QChem output file 
    # '''
    
    name=$1
    name_force=$2 

    # unit in qchem: Hartree/Bohr
    echo '!Forces, #state, #component' >> $name
    for ((stat_i=1; stat_i<= $nstat ; stat_i++))
    do 
        # extrat gradient to meta file totforce.tmp 
        # format: one row has infor. for 6 atoms
        grep -A 4 'Gradient of the state energy (including CIS Excitation Energy)' $name_force\_$stat_i.out | tail -n 3 | awk '{print $2,$3,$4,$5,$6,$7}' > totforce.tmp 
        # TODO: change this part 
        if (( $natom > 6 ))
        then 
            grep -A 8 'Gradient of the state energy (including CIS Excitation Energy)' $name_force\_$stat_i.out | tail -n 3 | awk '{print $2,$3,$4,$5,$6,$7}' > totforce1.tmp
            mv totforce.tmp tmp 
            paste tmp totforce1.tmp > totforce.tmp 
            rm -f tmp totforce1.tmp  
        fi 

        rm -f force.tmp 
        atom_idx=1
        for ((na=1; na<=$natom; na++))
        do 
                awk "{ print \$$na }" totforce.tmp >> force.tmp 
            for ((j=1;j<=3;j++)) 
            do
                force=$(sed -n "$atom_idx,$atom_idx p" force.tmp)
                
                # change sign by checking the first character 
                # negative -> remove the negative sign
                # positive -> add the negative sign
                [ ${force:0:1} = - ] && force=$( echo $force | cut -c2-) || force=$( echo $force | sed 's/^/-/g' )

                echo $force $stat_i $atom_idx >> $name
                atom_idx=$(($atom_idx + 1))
            done 
        done 
    done 
    rm -f totforce.tmp force.tmp 
}

function genqchemInp(){
    # '''
    #     $1 = name of the file
    #     $2 = one geometry file (Bohr)
    #     $3 = qchemOption.tmp
    # '''

    # Change unit from Bohr to Angstrom
    Bohr2Ang $2 # output: geom_ang.tmp 

cat << EOF > $1.inp
\$molecule
    $charge $multi
`paste atomlist.tmp geom_ang.tmp`
\$end

EOF
cat $3 >> $1.inp
rm -f atomlist.tmp geom_bohr.tmp geom_ang.tmp 
}

function testBL(){
    # input: 
    #   $1 = *.1; dynamic information input fule

    Bohr2Ang $1 # output: geom_ang.tmp 
    genBondsFile geom_ang.tmp # output: ${Bonds[@]}

    # test all C-H bond length; larger than 5, return 1
    nCH_5=0 
    for ((bond_i=0;bond_i<4;bond_i++))
    do 
        BLint=$(echo ${Bonds[$bond_i]} | cut -d '.' -f 1 ) 
        if [[ $BLint -gt 5  ||  $BLint -eq 5 ]]
        then 
            nCH_5=$(($nCH_5 + 1 ))
        fi 
    done 

    if [ $nCH_5 -gt 1 ] 
    then 
        echo 1 # 2 CH bonds are larger than 5 angstrom 
    else 
        echo 0 
    fi 

}

function Bohr2Ang(){
    # input:
    #   $1 = *.1 ; dynamic information input fule
    # output: 
    #   geom_ang.tmp 

    bohr2ang=0.5292
    sed -n "5, $((4 + $natom)) p" $1 | awk '{print $1}' > atomlist.tmp 
    sed -n "5, $((4 + $natom)) p" $1 | awk '{print $2, $3, $4}' > geom_bohr.tmp 
    rm -f geom_ang.tmp 
    for ((natom_i=1;natom_i<=$natom;natom_i++))
    do 
        x_bohr=$(sed -n "$natom_i,$natom_i p" geom_bohr.tmp | awk '{print $1}')
        y_bohr=$(sed -n "$natom_i,$natom_i p" geom_bohr.tmp | awk '{print $2}')
        z_bohr=$(sed -n "$natom_i,$natom_i p" geom_bohr.tmp | awk '{print $3}')
        x_ang=$( awk " BEGIN {print $x_bohr * $bohr2ang }")
        y_ang=$( awk " BEGIN {print $y_bohr * $bohr2ang }")
        z_ang=$( awk " BEGIN {print $z_bohr * $bohr2ang }")
        echo $x_ang $y_ang $z_ang >> geom_ang.tmp 
    done

}

function genBondsFile(){
    # intput:
    #   $1 = geom_ang.tmp 
    # output: 
    #   ${Bonds[@]}

    coord=()
    for ((coord_i=1;coord_i<=$natom;coord_i++))
    do 
        coord+=($(sed -n "$coord_i,$coord_i p" $1 | awk '{print $1}'))
        coord+=($(sed -n "$coord_i,$coord_i p" $1 | awk '{print $2}'))
        coord+=($(sed -n "$coord_i,$coord_i p" $1 | awk '{print $3}'))
    done 
    C=( $(echo ${coord[@]:0:3}) )
    H1=( $(echo ${coord[@]:3:3}) )
    H2=( $(echo ${coord[@]:6:3}) )
    H3=( $(echo ${coord[@]:9:3}) )
    H4=( $(echo ${coord[@]:12:3}) )

    Bonds=() 
    Bonds+=($(calcBL ${C[@]} ${H1[@]} ))
    Bonds+=($(calcBL ${C[@]} ${H2[@]} ))
    Bonds+=($(calcBL ${C[@]} ${H3[@]} ))
    Bonds+=($(calcBL ${C[@]} ${H4[@]} ))
    Bonds+=($(calcBL ${H1[@]} ${H2[@]} ))
    Bonds+=($(calcBL ${H1[@]} ${H3[@]} ))
    Bonds+=($(calcBL ${H1[@]} ${H4[@]} ))
    Bonds+=($(calcBL ${H2[@]} ${H3[@]} ))
    Bonds+=($(calcBL ${H2[@]} ${H4[@]} ))
    Bonds+=($(calcBL ${H3[@]} ${H4[@]} ))
}

function calcBL(){
    # $1 - $3 = first atom
    # $4 - $6 = second atom
    # output: bond length between atom1 and atom2

    atom1=() 
    atom1+=($1)
    atom1+=($2)
    atom1+=($3)
    atom2=() 
    atom2+=($4)
    atom2+=($5)
    atom2+=($6)

    BL12=()
    for ((coord_i=0;coord_i<3;coord_i++))
    do 
        minusSign=$(echo ${atom2[$coord_i]} | grep -c '-')
        if [ $minusSign == 0 ]
        then 
            BL12+=($(echo "scale=4;(${atom1[$coord_i]}-${atom2[$coord_i]})^2 "|bc -l))
        else
            num2=$(echo ${atom2[$coord_i]} | sed 's/-//g')
            BL12+=($(echo "scale=4;(${atom1[$coord_i]} + $num2 )^2 "|bc -l))
        fi 
    done 

    echo "scale=4;sqrt(${BL12[0]} + ${BL12[1]} + ${BL12[2]})"| bc -l
}

function qchemOptionNonad(){
    # $1 = Read or SAD
    
cat << EOF > qchemOption.tmp
\$rem
    !EXCHANGE            HF
    !CORRELATION         CI
    EXCHANGE            BHHLYP !50% HF +  50% Becke88 exchange
    BASIS               6-31+G*
    UNRESTRICTED        True
    MAX_SCF_CYCLES      500
    SYM_IGNORE          True
    SCF_Algorithm       DIIS
    SCF_GUESS           $1 

    SPIN_FLIP           True
    SET_Iter            100

    CALC_NAC            True 
    CIS_DER_NUMSTATE    $nstat  
    
    CIS_N_ROOTS         $nstat 
\$end

\$derivative_coupling
   comment https://manual.q-chem.com/5.0/sec-MECPs.html
    ${statlist[@]}
\$end

EOF
}

function qchemOptionForce(){
    # $1 = idx. of state 
cat << EOF > qchemOption.tmp
\$rem
    JOBTYPE             Force
    !EXCHANGE            HF
    !CORRELATION         CI
    EXCHANGE            BHHLYP !50% HF +  50% Becke88 exchange 
    BASIS               6-31+G*
    UNRESTRICTED        True
    MAX_SCF_CYCLES      500
    SYM_IGNORE          True
    SCF_Algorithm       DIIS
    SCF_GUESS           Read

    SPIN_FLIP           True
    SET_Iter            300

    CIS_N_ROOTS         $1
    CIS_STATE_DERIV     $1
    CIS_TRIPLETS        False
\$end

EOF
}

function check_calc(){
    # $1 = directory to storing wavefunction 
    # $2 = name of the file 

    num=$(grep -c 'Thank you very much for using Q-Chem' $2.out )
    if [ $num -eq 0 ]
    then
        err=$(grep -c 'SCF failed to converge' $2.out )
        if [ $err -eq 1 ]
        then
            echo 'Change SCF algorithm to GDM'
            sed -i 's/DIIS/GDM/g' $2.inp
            $qchemProg $2.inp $1 > $2.out
            return 0
        else
            echo "Failed Q-Chem output: $2.out" 
            exit 1 
            # echo "Failed Q-Chem output; mix 10% orb in SCF and then rerun $1.inp"
            # sed -i 's/SCF_GUESS           Read/SCF_GUESS           Read \n SCF_GUESS_MIX 3/' $1.inp 
        fi
    else 
        echo $2.out
        return 1 
    fi
}

main $@