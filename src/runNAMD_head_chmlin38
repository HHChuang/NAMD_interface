#!/bin/bash
# '''
#     2022/07/06, Grace, H.G.Chuang@leeds.ac.uk
#     $1 = first point; *.0
# '''

function main(){
    # 1. Check environmental variables, and set up parameters
    source ~/.bashrc
    qchemProg="$QC/exe/qcprog.exe_s"
    propPrelim="/localhome/chmhch/bin/prop_prelim.x"
    propCorr="/localhome/chmhch/bin/prop_corr.x"
    nsteps=3000 # number of propagation steps 
    charge=0
    multi=3 

    checkInput $1 # output: $natom, $stat, $statlist()

    # 2. Propagate trajectory
    propTraj $1 $nsteps 
}

function checkInput(){
    # $1 = name of first point with dynamic information 
    # output: 
    #   $natom
    #   $stat
    #   $statlist()

    [ "$1" == "" ] && echo "file $1 is not exist, exit" && exit

    natom=$(head -n 1 $1 | awk '{print $1}')
    
    stat=$(head -n 1 $1  | awk '{print $2}')
    statlist=()
    for ((i=1; i <= $stat; i++))
    do 
        statlist+=($i)
    done
    # echo ${statlist[@]}

}

function propTraj(){
    # '''
    #     $1 = dynamics information for the first point; *.0
    #     $2 = number of propagation steps 
    # '''
    
    # Step 1. Calculate the first point 
    # '''
    #     output: 
    #     1. $root_name.1
    #     2. $root_name\_nonad.out 
    #     3. $root_name\_force_#.out 
    #     4. /$root_name\_WF
    # '''
    root_name=$(echo $1 | cut -d '.' -f 1) 
    prop1PT $root_name SAD 
    
    # Step 2. Calculate the following points
    nsteps=$2 
    pt_name_i=$root_name
    nwfDir=3
    for (( step_i=1;step_i<=$nwfDir;step_i++ ))
    do 
        pt_name=$root_name\_$step_i
        cp $pt_name_i.1 $pt_name.0
        cp -r $pt_name_i\_WF $pt_name\_WF
        prop1PT $pt_name Read
        pt_name_i=$pt_name 
    done 
    for (( step_i=$(($nwfDir+1));step_i<=$nsteps;step_i++ ))
    do 
        pt_name=$root_name\_$step_i
        cp $pt_name_i.1 $pt_name.0
        cp -r $pt_name_i\_WF $pt_name\_WF
        prop1PT $pt_name Read
        pt_name_i=$pt_name 
        echo $root_name\_[1:$(($step_i-$nwfDir))]\_WF | xargs rm -rf 
    done 
    rm -f qchemOption.tmp tmp.tmp 
}

function prop1PT(){
    # '''
    #     $1 = root of filename which has dynamics information for the initial point; $1.0
    #     $2 = syntax for electronic wavefunction 
    #     output:
    #         $1.1
    # '''
     
    # Step 1. Preliminary calculation
    $propPrelim $1 # input: $1.0, output: $1.p

    # Step 2. Electronic structure calculation
    # Step 2.1. Nonadiabatic calculation
    #   calculate electronic energy and store WF 
    name=$1\_nonad
    qchemOptionNonad $2 # output: qchemOption.tmp
    genqchemInp  $name $1.p qchemOption.tmp
    $qchemProg $name.inp $1\_WF > $name.out
    check_calc $1\_WF $name


    # Step 2.2. Force calculation in different excited state
    for (( i=1;i<=$stat;i++ ))
    do 
        name_f=$1\_force\_$i
        qchemOptionForce $i # output: qchemOption.tmp
        genqchemInp $name_f $1.p qchemOption.tmp
        $qchemProg $name_f.inp $1\_WF > $name_f.out
        check_calc $1\_WF $name_f
    done 

    # Step 2.3 Add EST data to the dynamic calculation input file 
    # echo '!Potential energies, #state' >> $1.p
    grep 'Total energy for state ' $1\_nonad.out \
        | awk '{print $6, $5}' | sed 's/://g' | head -n $stat >> $1.p
    
    get_force $1.p $1\_force_ $natom $stat
    get_nonad $1.p $1\_nonad.out $natom $stat
    
    # Step 3. Correction of dynamic information
    # Correct final momenta and Ehrenfest amplitudes using electronic structure data from both initial and final point
    $propCorr $1 # output: $1.1
}

function get_nonad(){
    # $1 = name of input for dynamic calculation
    # $2 = name of QChem output file 
    # $3 = $natom
    # $4 = $stat

    name=$1
    name_nonad=$2 
    natom=$3 
    stat=$4

    echo '!Coupling vector, #state1 < #state2,  #component !!The code reads only 3*n_atoms*n_states*(n_states-1) lines for coupling!!!' >> $name
    # FIXME: with or without ? 
    k=0
    for ((i=1; i<=$stat; i++))
    do 
        for ((j=$i+1; j<=$stat; j++))
        do
            grep -A $(($natom + 2 )) 'derivative coupling with ' $name_nonad \
            | sed -n "$((4 + $k*9)), $((8 + $k*9)) p" | awk '{print $2,$3,$4}' > coupling.tmp 
            component=1
            for ((na=1; na<=$natom; na++))
            do 
                for ((coord=1; coord<=3; coord++))
                do 
                    cp=$(sed -n "$na, $na p " coupling.tmp | awk "{print \$$coord}" ) 
                    echo $cp $i $j $component >> $name
                    component=$(($component + 1))
                done 
            done 
            k=$(($k + 1)) # derivative coupling matrix 
        done 
    done 
    rm -f coupling.tmp 
}

function get_force(){
    # '''
    #     $1 = name of input for dynamic calculation
    #     $2 = root name of QChem output file 
    #     $3 = $natom
    #     $4 = $stat
    # '''
    
    name=$1
    name_force=$2 
    natom=$3 
    stat=$4

    echo '!Forces, #state, #component' >> $name
    for ((i=1; i<=$stat; i++))
    do 
        component=1 
        for ((na=1; na<=$natom; na++))
        do 
            grep -A 5 'Calculating analytic gradient of the SCF energy' $name_force$i.out \
            | tail -n 3 | awk "{print \$$(($na+1))}" >> force.tmp 
            for ((j=1;j<=3;j++)) 
            do
                force=$(sed -n "$j,$j p" force.tmp)
                echo $force $i $component >> $name
                component=$(($component + 1))
            done 
        done 
    done 
    rm -f force.tmp 
}

function genqchemInp(){
    # '''
    #     $1 = name of the file
    #     $2 = one geometry file 
    #     $3 = qchemOption.tmp
    # '''

cat << EOF > $1.inp
\$molecule
    $charge $multi
`sed -n "5, $((4 + $natom)) p" $2`
\$end

EOF
cat $3 >> $1.inp
}

function qchemOptionNonad(){
    # $1 = Read or SAD
    
cat << EOF > qchemOption.tmp
\$rem
    !EXCHANGE            HF
    !CORRELATION         CI
    EXCHANGE            BHHLYP !50% HF +  50% Becke88 exchange
    BASIS               6-31+G*
    UNRESTRICTED        True
    MAX_SCF_CYCLES      500
    SYM_IGNORE          True
    SCF_Algorithm       DIIS
    SCF_GUESS           $1 

    SPIN_FLIP           True
    SET_Iter            100

    CALC_NAC            True 
    CIS_DER_NUMSTATE    $stat  
    
    CIS_N_ROOTS         $stat 
\$end

\$derivative_coupling
   comment https://manual.q-chem.com/5.0/sec-MECPs.html
    ${statlist[@]}
\$end

EOF
}

function qchemOptionForce(){
    # $1 = idx. of state 
cat << EOF > qchemOption.tmp
\$rem
    JOBTYPE             Force
    !EXCHANGE            HF
    !CORRELATION         CI
    EXCHANGE            BHHLYP !50% HF +  50% Becke88 exchange 
    BASIS               6-31+G*
    UNRESTRICTED        True
    MAX_SCF_CYCLES      500
    SYM_IGNORE          True
    SCF_Algorithm       DIIS
    SCF_GUESS           Read

    SPIN_FLIP           True
    SET_Iter            100

    CIS_STATE_DERIV     $1
    CIS_TRIPLETS        False
\$end

EOF
}

function check_calc(){
    # $1 = directory to storing wavefunction 
    # $2 = name of the file 

    num=$(grep -c 'Thank you very much for using Q-Chem' $2.out )
    if [ $num -eq 0 ]
    then
        err=$(grep -c 'SCF failed to converge' $2.out )
        if [ $err -eq 1 ]
        then
            echo 'Change SCF algorithm to GDM'
            sed -i 's/DIIS/GDM/g' $2.inp
            $qchemProg $2.inp $1 > $2.out
            return 0
        else
            echo "Failed Q-Chem output: $2.out" 
            exit 1 
            # echo "Failed Q-Chem output; mix 10% orb in SCF and then rerun $1.inp"
            # sed -i 's/SCF_GUESS           Read/SCF_GUESS           Read \n SCF_GUESS_MIX 3/' $1.inp 
        fi
    else 
        echo $2.out
        return 1 
    fi
}

main $1 