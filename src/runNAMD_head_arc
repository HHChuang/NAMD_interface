#!/bin/bash
'''
    2022/05/18, Grace, H.G.Chuang@leeds.ac.uk
    $1 = first point; *.0
'''

function main(){
    # 1. Check environmental variables, and set up parameters
    # export QC='/nobackup/chmhch/opt/qchem/5.4.0'
    # source $QC/qcenv.sh 
    # qchemProg="$QC/exe/qcprog.exe"
    # propPrelim="/home/home02/chmhch/methane_src/prop_prelim.x"
    # proCorr="/home/home02/chmhch/methane_src/prop_coor.x"
    nsteps=2 # number of propagation steps 
    charge=0
    multi=1 

    checkInput $1 # output: $natom, $stat, $statlist()

    # 2. Propagate trajectory
    propTraj $1 $nsteps 

}

function checkInput(){
    # $1 = name of first point with dynamic information 
    # output: 
    #   $natom
    #   $stat
    #   $statlist()

    [ "$1" == "" ] && echo "file $1 is not exist, exit" && exit

    natom=$(head -n 1 $1 | awk '{print $1}')
    
    stat=$(head -n 1 $1  | awk '{print $2}')
    statlist=()
    for ((i=1; i <= $stat; i++))
    do 
        statlist+=($i)
    done
    # echo ${statlist[@]}

}

function propTraj(){
    '''
        $1 = dynamics information for the first point; *.0
        $2 = number of propagation steps 
    '''
    
    # Step 1. Calculate the first point 
    '''
        output: 
        1. $root_name.1
        2. $root_name\_nonad.out 
        3. $root_name\_force_#.out 
        4. /$root_name\_WF
    '''
    root_name=$(echo $1 | cut -d '.' -f 1) 
    prop1PT $root_name SAD 
    
    # Step 2. Calculate the following points
    nsteps=$2 
    name_i=$root_name
    for (( i=1;i<=$nsteps;i++ ))
    do 
        name=$root_name\_$i
        cp $name_i.1 $name.0
        cp -r $name_i\_WF $name\_WF
        prop1PT $name Read
        name_i=$name 
    done 
    rm -f qchemOption.tmp tmp.tmp 
}

function prop1PT(){
    '''
        $1 = root of filename which has dynamics information for the initial point; $1.0
        $2 = syntax for electronic wavefunction 
        output:
            $1.1
    '''
    # 
    # Step 1. Preliminary calculation
    $propPrelim $1 # input: $1.o, output: $1.p

    # Step 2. Electronic structure calculation
    

    # Step 2.1. Nonadiabatic calculation
    #   calculate electronic energy and store WF 
    name=$1\_nonad
    qchemOptionNonad $2 # output: qchemOption.tmp
    genqchemInp  $name $1.p qchemOption.tmp
    $qchemProg $name.inp $name\_WF > $name.out
    # TODO: check qchem output, if fails recalculate it 

    # Step 2.2. Force calculation in different excited state
    for (( i=1;i<=$stat;i++ ))
    do 
        name=$1\_force\_$i
        qchemOptionForce $i # output: qchemOption.tmp
        genqchemInp $name $1.p qchemOption.tmp
        $qchemProg $name.inp $name\_WF > $name.out
        # TODO: check qchem output, if fails recalculate it 
    done 

    # Step 2.3 Add EST data to the dynamic calculation input file 
    echo '!Potential energies, #state' >> $1.p
    grep 'Total energy for state ' $1\_nonad.out \
        | awk '{print $6, $5}' | sed 's/://g' >> $1.p
    
    get_force $1.p $1\_force_ $natom $stat
    get_nonad $1.p $1\_nonad.out $natom $stat
    
    # Step 3. Correction of dynamic information
    # Correct final momenta and Ehrenfest amplitudes using electronic structure data from both initial and final point
    $propCorr $1 # output: $1.1
}

function get_nonad(){
    # $1 = name of input for dynamic calculation
    # $2 = name of QChem output file 
    # $3 = $natom
    # $4 = $stat

    name=$1
    name_nonad=$2 
    natom=$3 
    stat=$4

    echo '!Coupling vector, #state1 < #state2,  #component !!The code reads only 3*n_atoms*n_states*(n_states-1) lines for coupling!!!' >> $name
    # FIXME: with or without ? 
    k=0
    for ((i=1; i<=$stat; i++))
    do 
        for ((j=$i+1; j<=$stat; j++))
        do
            grep -A $(($natom + 2 )) 'derivative coupling with ' $name_nonad \
            | sed -n "$((4 + $k*9)), $((8 + $k*9)) p" | awk '{print $2,$3,$4}' > coupling.tmp 
            component=1
            for ((na=1; na<=$natom; na++))
            do 
                for ((coord=1; coord<=3; coord++))
                do 
                    cp=$(sed -n "$na, $na p " coupling.tmp | awk "{print \$$coord}" ) 
                    echo $cp $i $j $component >> $name
                    component=$(($component + 1))
                done 
            done 
            k=$(($k + 1)) # derivative coupling matrix 
        done 
    done 
    rm -f coupling.tmp 
}

function get_force(){
    '''
        $1 = name of input for dynamic calculation
        $2 = root name of QChem output file 
        $3 = $natom
        $4 = $stat
    '''
    
    name=$1
    name_force=$2 
    natom=$3 
    stat=$4

    echo '!Forces, #state, #component' >> $name
    for ((i=1; i<=$stat; i++))
    do 
        component=1 
        for ((na=1; na<=$natom; na++))
        do 
            grep -A 5 'Calculating analytic gradient of the SCF energy' $name_force$i.out \
            | tail -n 3 | awk "{print \$$(($na+1))}" >> force.tmp 
            for ((j=1;j<=3;j++)) 
            do
                force=$(sed -n "$j,$j p" force.tmp)
                echo $force $i $component >> $name
                component=$(($component + 1))
            done 
        done 
    done 
    rm -f force.tmp 
}

function genqchemInp(){
    '''
        $1 = name of the file
        $2 = one geometry file 
        $3 = qchemOption.tmp
    '''

cat << EOF > $1.inp
\$molecule
    $charge $multi
`sed -n "5, $((4 + $natom)) p" $2`
\$end

EOF
cat $3 >> $1.inp
}

function qchemOptionNonad(){
    # $1 = Read or SAD
    
cat << EOF > qchemOption.tmp
\$rem
    !EXCHANGE            HF
    !CORRELATION         CI
    EXCHANGE            BHHLYP !50% HF +  50% Becke88 exchange
    BASIS               6-31+G*
    UNRESTRICTED        True
    MAX_SCF_CYCLES      500
    SYM_IGNORE          True
    SCF_Algorithm       DIIS
    SCF_GUESS           $1 

    SPIN_FLIP           True
    SET_Iter            100

    CALC_NAC            True 
    CIS_DER_NUMSTATE    $stat  
    
    CIS_N_ROOTS         $stat 
\$end

\$derivative_coupling
   comment https://manual.q-chem.com/5.0/sec-MECPs.html
    ${statlist[@]}
\$end

EOF
}

function qchemOptionForce(){
    # $1 = idx. of state 
cat << EOF > qchemOption.tmp
\$rem
    JOBTYPE             Force
    !EXCHANGE            HF
    !CORRELATION         CI
    EXCHANGE            BHHLYP !50% HF +  50% Becke88 exchange 
    BASIS               6-31+G*
    UNRESTRICTED        True
    MAX_SCF_CYCLES      500
    SYM_IGNORE          True
    SCF_Algorithm       DIIS
    SCF_GUESS           Read

    SPIN_FLIP           True
    SET_Iter            100

    CIS_STATE_DERIV     $1
    CIS_TRIPLETS        False
\$end

EOF
}

function checkoutput_nonad(){
    # $1 = name of the file 

    num=$(grep -c 'Thank you very much for using Q-Chem' $1.out )
    if [ $num -eq 0 ]
    then
        err=$(grep -c 'SCF failed to converge' $1.out )
        if [ $err -eq 1 ]
        then
            echo 'Change SCF algorithm to GDM'
            sed -i 's/DIIS/GDM/g' $1.inp
            return 0
        else
            echo "Failed Q-Chem output: $1.out" 
            exit
            # echo "Failed Q-Chem output; mix 10% orb in SCF and then rerun $1.inp"
            # sed -i 's/SCF_GUESS           Read/SCF_GUESS           Read \n SCF_GUESS_MIX 3/' $1.inp 
        fi
    else 
        echo $1.out
        return 1 
    fi
}

function checkoutput_force(){
    # $1 = name of the file 
    num=$(grep -c 'Thank you very much for using Q-Chem' $1 )
    if [ $num -eq 0 ]
    then
        echo "Q-Chem failed to run, please check $1"
        exit
    else 
        echo $1 
    fi
}

main $1 